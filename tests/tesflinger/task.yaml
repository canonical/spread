summary: Test testflinger backend using a mock server

environment:
    TF_ENDPOINT: http://127.0.0.1:5005
    TF_API_VERSION: v1

prepare: |
    if [ ! -f .spread-reuse.yaml ]; then
        touch /run/spread-reuse.yaml
        ln -s /run/spread-reuse.yaml .spread-reuse.yaml
    fi
    apt install -y python3-flask jq

restore: |
    pids="$(ps -ef | grep -E 'python3 fake_testflinger.py' | grep -v 'grep' | awk '{print $2}')"
    if [ -n "$pids" ]; then
        for pid in $pids; do
           kill -9 "$pid"
        done
    fi
    apt remove -y python3-flask jq

    # Clean all the data files generated by the mock
    rm *.data mock.log
  
debug: |
    cat /tmp/task.out || true

execute: |
    start_mock(){
        python3 fake_testflinger.py "$1" &>mock.log &
        sleep 1
    }

    stop_mock(){
        pids="$(ps -ef | grep -E 'python3 fake_testflinger.py' | grep -v 'grep' | awk '{print $2}')"
        if [ -n "$pids" ]; then
            for pid in $pids; do
               kill -9 "$pid"
            done
        fi
    }

    # Basic scenario rpi4 with url
    start_mock 00000000-0000-0000-0000-000000000001
    ! spread -reuse -resend testflinger:ubuntu-core-22-rpi4: &> /tmp/task.out
    cat /tmp/task.out | grep 'TestFlinger job 00000000-0000-0000-0000-000000000001 created for'
    cat /tmp/task.out | grep 'Waiting for TestFlinger ubuntu-core-22-rpi4 to have an address...'
    cat /tmp/task.out | grep 'Allocated device with ip 127.0.0.1'
    cat /tmp/task.out | grep 'unable to authenticate'
    test "$(jq -r '.job_queue' job_00000000-0000-0000-0000-000000000001.data)" = "rpi4b"
    test "$(jq -r '.action' action_00000000-0000-0000-0000-000000000001.data)" = "cancel"
    test "$(jq -r '.provision_data.url' job_00000000-0000-0000-0000-000000000001.data)" = "https://url/pi.img.xz"
    test -z "$(jq -r '.provision_data | keys[]' job_00000000-0000-0000-0000-000000000001.data | grep distro)"
    stop_mock

    # Cancel scenario with distro
    start_mock 00000000-0000-0000-0000-000000000002
    ! spread -reuse -resend testflinger:ubuntu-core-22-64: &> /tmp/task.out
    cat /tmp/task.out | grep 'TestFlinger job 00000000-0000-0000-0000-000000000002 created for'
    cat /tmp/task.out | grep 'Waiting for TestFlinger ubuntu-core-22-64 to have an address...'
    cat /tmp/task.out | grep 'Job state is either cancelled or completed'
    test "$(jq -r '.job_queue' job_00000000-0000-0000-0000-000000000002.data)" = "x64"
    test "$(jq -r '.provision_data.distro' job_00000000-0000-0000-0000-000000000002.data)" = "jammy"
    test -z "$(jq -r '.provision_data | keys[]' job_00000000-0000-0000-0000-000000000002.data | grep url)"
    ! test -f action_00000000-0000-0000-0000-000000000002.data
    stop_mock

    # Complete scenario
    start_mock 00000000-0000-0000-0000-000000000003
    ! spread -reuse -resend testflinger:ubuntu-core-22-rpi4: &> /tmp/task.out
    cat /tmp/task.out | grep 'TestFlinger job 00000000-0000-0000-0000-000000000003 created for'
    cat /tmp/task.out | grep 'Waiting for TestFlinger ubuntu-core-22-rpi4 to have an address...'
    cat /tmp/task.out | grep 'Job state is either cancelled or completed'
    stop_mock

    # Garbage collection scenario
    # Job 4: has to be deleted (it is active and halt-timeout exceeded)
    # Job 5: has not to be deleted (it is active but halt-timeout not exceeded)
    # Job 6: has not to be deleted (it is not active)
    # Job 7: has not to be deleted (it is not active)
    start_mock 00000000-0000-0000-0000-000000000004
    spread -gc &> /tmp/task.out
    cat /tmp/task.out | grep 'Checking 00000000-0000-0000-0000-000000000004'
    cat /tmp/task.out | grep 'Job 00000000-0000-0000-0000-000000000004 exceeds halt-timeout. Shutting it down...'
    cat /tmp/task.out | grep 'Checking 00000000-0000-0000-0000-000000000005'
    test "$(jq -r '.action' action_00000000-0000-0000-0000-000000000004.data)" = "cancel"
    stop_mock
